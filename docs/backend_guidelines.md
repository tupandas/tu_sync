# Backend Guidelines for `offline_first_sync_drift`

## Table of Contents

- [Introduction](#introduction)
- [Simplified Flow](#simplified-flow)
  - [REST Endpoints](#rest-endpoints)
  - [Model Fields](#model-fields)
  - [POST: create](#post-create)
  - [PUT: upsert](#put-upsert)
  - [DELETE](#delete)
  - [GET by ID](#get-by-id)
  - [Pagination](#pagination)
  - [Checklist](#checklist-simplified-flow)
- [Full Flow](#full-flow-with-conflict-handling)
  - [PUT with conflicts](#put-with-conflict-check)
  - [DELETE with conflicts](#delete-with-conflict-check)
  - [409 Conflict response format](#409-conflict-response-format)
  - [Batch API](#batch-api-optional)
  - [Checklist](#checklist-full-flow)
- [Shared Topics](#shared-topics)
  - [System Fields](#system-fields)
  - [Health Endpoint](#health-endpoint-optional)
  - [ETag](#etag-optional)
  - [Rate Limiting](#rate-limiting-optional)
- [FAQ](#faq)

---

## Introduction

`offline_first_sync_drift` is a client library for offline-first synchronization. This document describes the requirements for the server REST API.

### Two usage scenarios

| Scenario | When to use | Complexity |
|----------|-------------|------------|
| **Simplified** | One client, one account, backend does not modify data | Minimal |
| **Full** | Multiple clients/devices, backend may add/modify data | Requires conflict handling |

> Start with the simplified flow. Add conflict handling only if you need multiple clients or server-side writers.

---

# Simplified Flow

**Use this flow if:**
- Single app/account
- Single device (or devices do not work concurrently)
- Backend only stores data and never mutates it on its own

In this flow **conflicts cannot happen**, so `_baseUpdatedAt` checks are not needed.

## REST Endpoints

| Method | URL | Purpose |
|--------|-----|---------|
| `GET` | `/{kind}` | List records with filtering and pagination |
| `GET` | `/{kind}/{id}` | Get a single record |
| `POST` | `/{kind}` | Create a new record |
| `PUT` | `/{kind}/{id}` | Update record (upsert) |
| `DELETE` | `/{kind}/{id}` | Delete record |

`{kind}` is the entity name. You can implement it as:
- Separate controllers: `/daily_feeling`, `/health_record`
- Or a dynamic parameter with a whitelist of allowed entities

## Model Fields

| Field | Type | Description |
|-------|------|-------------|
| `id` | `string` | Unique identifier (UUID), **generated by the client** |
| `updated_at` | `datetime` | Last update time (UTC), **set by the server** |

> The client supports both `snake_case` (`updated_at`) and `camelCase` (`updatedAt`).

```json
{
  "id": "abc-123",
  "mood": 5,
  "energy": 7,
  "updated_at": "2025-01-15T10:30:00Z"
}
```

## POST: create

The client **usually generates `id` itself** and uses PUT. POST is rarely used (when `id` is empty).

Return `201 Created` with the created record.

```javascript
async function handlePost(req, res) {
  const { kind } = req.params;
  
  // id comes from the client or is generated on the server
  const id = req.body.id || generateUUID();
  
  // Remove system fields from payload
  const payload = stripSystemFields(req.body);
  const now = new Date().toISOString();

  await db(kind).insert({
    ...payload,
    id,
    updated_at: now,
  });

  const result = await db(kind).where({ id }).first();
  return res.status(201).json(result);
}
```

## PUT: upsert

PUT acts as an **upsert**: if the record does not exist, it creates it.

The client may send `_baseUpdatedAt` in the body — **ignore it** in the simplified flow.

```javascript
async function handlePut(req, res) {
  const { kind, id } = req.params;  // id from URL
  const payload = stripSystemFields(req.body);
  const now = new Date().toISOString();

  const existing = await db(kind).where({ id }).first();

  if (!existing) {
    await db(kind).insert({ ...payload, id, updated_at: now });
    const result = await db(kind).where({ id }).first();
    return res.status(201).json(result);
  }

  await db(kind).where({ id }).update({ ...payload, updated_at: now });
  const result = await db(kind).where({ id }).first();
  return res.json(result);
}
```

## DELETE

The client may send `_baseUpdatedAt` as a query parameter — **ignore it** in the simplified flow.

```javascript
async function handleDelete(req, res) {
  const { kind, id } = req.params;

  const existing = await db(kind).where({ id }).first();
  if (!existing) {
    return res.status(404).json({ error: 'not_found' });
  }

  await db(kind).where({ id }).delete();
  return res.status(204).end();
}
```

## GET by ID

```javascript
async function handleGet(req, res) {
  const { kind, id } = req.params;

  const record = await db(kind).where({ id }).first();
  if (!record) {
    return res.status(404).json({ error: 'not_found' });
  }

  return res.json(record);
}
```

## Pagination

### Request

```http
GET /daily_feeling?updatedSince=2025-01-01T00:00:00Z&limit=500&includeDeleted=true
```

| Parameter | Description |
|-----------|-------------|
| `updatedSince` | Return records with `updated_at >= value` |
| `limit` | Max records (recommended 500) |
| `pageToken` | Next page token |
| `afterId` | Client may send it — can be ignored if you use `pageToken` |
| `includeDeleted` | Include soft-deleted records (default `true`) |

### Response

```json
{
  "items": [
    {"id": "abc-123", "mood": 5, "updated_at": "2025-01-15T10:00:00Z"},
    {"id": "def-456", "mood": 3, "updated_at": "2025-01-15T10:05:00Z"}
  ],
  "nextPageToken": "10"
}
```

`nextPageToken` is `null` on the last page.

### Simple offset-based implementation

```javascript
async function handleList(req, res) {
  const { kind } = req.params;
  const { updatedSince, pageToken } = req.query;
  const limit = parseInt(req.query.limit || '500', 10);
  const offset = parseInt(pageToken || '0', 10);
  // includeDeleted — for hard-delete can be ignored

  let query = db(kind).orderBy('updated_at', 'asc').orderBy('id', 'asc');
  
  if (updatedSince) {
    query = query.where('updated_at', '>=', updatedSince);
  }

  const items = await query.limit(limit).offset(offset);
  const nextPageToken = items.length === limit ? String(offset + limit) : null;

  return res.json({ items, nextPageToken });
}
```

## Checklist (simplified flow)

- [ ] Every model has `updated_at` set by the server
- [ ] `GET /{kind}` accepts `updatedSince`, `limit`, `pageToken`
- [ ] Sort by `(updated_at, id)` for stable pagination
- [ ] `GET` returns `{ "items": [...], "nextPageToken": "..." }`
- [ ] `POST` returns `201` with the created record
- [ ] `PUT` works as upsert
- [ ] `DELETE` returns `204`
- [ ] All `POST/PUT` responses include `updated_at`

---

# Full Flow (with conflict handling)

**Use this flow if:**
- Multiple devices can work concurrently
- Backend can mutate data (webhooks, cron jobs, admin tools)
- You need protection from data loss on concurrent updates

## What is added compared to the simplified flow

| Feature | Description |
|---------|-------------|
| `_baseUpdatedAt` check | Conflict detection |
| `409 Conflict` response | Returns current state on conflict |
| `X-Force-Update/Delete` | Forced update after client-side merge |
| `X-Idempotency-Key` | Protects against duplicates during retries |

## PUT with conflict check

### Request headers

| Header | Description |
|--------|-------------|
| `X-Idempotency-Key` | Unique operation key for safe retries |
| `X-Force-Update: true` | Skip conflict check (after client merge) |

### Request body

The client sends `_baseUpdatedAt` — timestamp of the record when it was fetched:

```json
{
  "mood": 7,
  "energy": 8,
  "_baseUpdatedAt": "2025-01-15T10:30:00Z"
}
```

### Processing algorithm

1. Read `X-Idempotency-Key`. If the operation already ran — return cached response.
2. Find the record. If it does not exist — create (upsert), return `201`.
3. Read `_baseUpdatedAt` from the body.
4. If `X-Force-Update != true` and `existing.updated_at != baseUpdatedAt` — return `409 Conflict`.
5. Update the record and set new `updated_at`.
6. Return `200` with the updated record.
7. Cache the response by `X-Idempotency-Key` for 24 hours.

### Example

```javascript
async function handlePut(req, res) {
  const { kind, id } = req.params;
  const idempotencyKey = req.header('x-idempotency-key');

  // Idempotency check
  if (idempotencyKey) {
    const cached = await cache.get(`idempotency:${idempotencyKey}`);
    if (cached) return res.json(cached);
  }

  const existing = await db(kind).where({ id }).first();
  const forceUpdate = req.header('x-force-update') === 'true';
  
  // Read _baseUpdatedAt BEFORE removing system fields
  const baseUpdatedAt = req.body._baseUpdatedAt;
  const payload = stripSystemFields(req.body);
  const now = new Date().toISOString();

  // Upsert
  if (!existing) {
    await db(kind).insert({ ...payload, id, updated_at: now });
    const result = await db(kind).where({ id }).first();
    return res.status(201).json(result);
  }

  // Conflict check
  if (!forceUpdate && baseUpdatedAt && existing.updated_at !== baseUpdatedAt) {
    return res.status(409).json({
      error: 'conflict',
      current: existing,
    });
  }

  await db(kind).where({ id }).update({ ...payload, updated_at: now });
  const result = await db(kind).where({ id }).first();

  if (idempotencyKey) {
    await cache.set(`idempotency:${idempotencyKey}`, result, 86400);
  }

  return res.json(result);
}
```

## DELETE with conflict check

`_baseUpdatedAt` is passed as a **query parameter**.

### Request headers

| Header | Description |
|--------|-------------|
| `X-Idempotency-Key` | Unique operation key |
| `X-Force-Delete: true` | Skip conflict check |

### Request example

```http
DELETE /daily_feeling/abc-123?_baseUpdatedAt=2025-01-15T10:30:00Z
X-Idempotency-Key: op-456
```

### Example

```javascript
async function handleDelete(req, res) {
  const { kind, id } = req.params;
  const idempotencyKey = req.header('x-idempotency-key');

  if (idempotencyKey) {
    const cached = await cache.get(`idempotency:${idempotencyKey}`);
    if (cached) return res.status(204).end();
  }

  const existing = await db(kind).where({ id }).first();
  if (!existing) {
    return res.status(404).json({ error: 'not_found' });
  }

  const forceDelete = req.header('x-force-delete') === 'true';
  const baseUpdatedAt = req.query._baseUpdatedAt;

  // Conflict check
  if (!forceDelete && baseUpdatedAt && existing.updated_at !== baseUpdatedAt) {
    return res.status(409).json({
      error: 'conflict',
      current: existing,
    });
  }

  await db(kind).where({ id }).delete();

  if (idempotencyKey) {
    await cache.set(`idempotency:${idempotencyKey}`, { deleted: true }, 86400);
  }

  return res.status(204).end();
}
```

## 409 Conflict response format

```json
{
  "error": "conflict",
  "current": {
    "id": "abc-123",
    "mood": 6,
    "energy": 9,
    "updated_at": "2025-01-15T11:00:00Z"
  }
}
```

| Field | Description |
|-------|-------------|
| `error` | Error code (`"conflict"`) |
| `current` | Current record state (must include `updated_at`) |

The client uses `current` to merge and repeats the request with `X-Force-Update: true` (or `X-Force-Delete: true`).

## Batch API (optional)

Batch processing can improve performance.

### Request

```http
POST /batch
Content-Type: application/json

{
  "ops": [
    {
      "opId": "op-001",
      "kind": "daily_feeling",
      "id": "abc-123",
      "type": "upsert",
      "payload": {"mood": 7, "energy": 8},
      "baseUpdatedAt": "2025-01-15T10:30:00Z"
    },
    {
      "opId": "op-002",
      "kind": "daily_feeling",
      "id": "def-456",
      "type": "delete",
      "baseUpdatedAt": "2025-01-15T10:00:00Z"
    }
  ]
}
```

### Response

```json
{
  "results": [
    {
      "opId": "op-001",
      "statusCode": 200,
      "data": {"id": "abc-123", "mood": 7, "updated_at": "2025-01-15T12:00:00Z"}
    },
    {
      "opId": "op-002",
      "statusCode": 409,
      "error": {
        "error": "conflict",
        "current": {"id": "def-456", "mood": 5, "updated_at": "2025-01-15T11:30:00Z"}
      }
    }
  ]
}
```

## Checklist (full flow)

Everything from the simplified flow, plus:

- [ ] `PUT` checks `_baseUpdatedAt`, returns `409` with `current` on conflict
- [ ] `DELETE` checks `_baseUpdatedAt` (query parameter)
- [ ] Supports headers `X-Force-Update`, `X-Force-Delete`
- [ ] Supports `X-Idempotency-Key` (24h cache)

### Optional

- [ ] `POST /batch` for batch processing
- [ ] Server returns `ETag` header
- [ ] Support `deleted_at` for soft delete

---

# Shared Topics

## System Fields

Remove system fields from the payload when saving — they are controlled by the server.

> **Important:** Extract required values (for example `_baseUpdatedAt`) **before** calling `stripSystemFields`.

```javascript
const SYSTEM_FIELDS = [
  'id', 'ID', 'uuid',
  'updatedAt', 'updated_at',
  'createdAt', 'created_at',
  'deletedAt', 'deleted_at',
  '_baseUpdatedAt',
];

function stripSystemFields(payload) {
  const result = { ...payload };
  for (const field of SYSTEM_FIELDS) {
    delete result[field];
  }
  return result;
}

// Usage example:
const baseUpdatedAt = req.body._baseUpdatedAt;  // extract first
const payload = stripSystemFields(req.body);    // then clean
```

## Health Endpoint (optional)

The client can call `GET /health` to check server availability.

```javascript
app.get('/health', (req, res) => {
  res.json({ status: 'ok' });
});
```

Return any `2xx` status if the server is healthy. The response body is not important.

## ETag (optional)

The server may return an `ETag` header:

```http
HTTP/1.1 200 OK
ETag: "v2"
Content-Type: application/json

{"id": "abc-123", "mood": 7, ...}
```

## Rate Limiting (optional)

On limit exceed:

```http
HTTP/1.1 429 Too Many Requests
Retry-After: 60
```

The client will automatically retry after the specified number of seconds.

---

# FAQ

## What is `{kind}` in the URL?

It is the entity/table name. Implement it however is convenient:

**Option 1:** Separate routes
```javascript
router.get('/daily_feeling', handleList);
router.get('/health_record', handleList);
```

**Option 2:** Dynamic parameter with whitelist
```javascript
const ALLOWED_KINDS = ['daily_feeling', 'health_record'];

router.get('/:kind', (req, res) => {
  if (!ALLOWED_KINDS.includes(req.params.kind)) {
    return res.status(404).json({ error: 'unknown_kind' });
  }
  return handleList(req, res);
});
```

## Where does the client take `_baseUpdatedAt` from?

When the client fetches a record (via GET) it stores `updated_at`. On the next update of this record the client sends the stored timestamp as `_baseUpdatedAt`.

This lets the server understand: “the client edited version from 10:30, but the server already has version from 11:00 — conflict!”

## Why check `!=` instead of `>`?

We use **strict equality** (`!=`), not “server is newer” (`>`), because:

1. Any change on the server (even with an older timestamp) means the client worked with stale data
2. Implementation is simpler — no date parsing, string compare is enough
3. Protects from edge cases with clock sync between servers

## What if `_baseUpdatedAt` is missing?

- **New record** (PUT to a missing id): `_baseUpdatedAt` is not needed, it is an upsert
- **Existing record without `_baseUpdatedAt`**: assume the client knows what it is doing — skip conflict check (same as `X-Force-Update`)

```javascript
if (!forceUpdate && baseUpdatedAt && existing.updated_at !== baseUpdatedAt) {
  // Conflict only if baseUpdatedAt is provided AND does not match
}
```

## What datetime format to use?

**ISO 8601 in UTC with `Z` suffix:**

```
2025-01-15T10:30:00Z
```

The client also parses other formats (`+00:00`, milliseconds), but `Z` is the most robust.

## Why `includeDeleted=true` by default?

For sync the client needs to know which records were deleted (soft-delete) to delete them locally.

If you use **hard-delete** — you can ignore this parameter.

## Soft delete vs hard delete?

**Hard delete** (simplified flow):
- Record is removed from DB
- Client will not know about deletion until a full resync
- Easier to implement

**Soft delete** (full flow):
- `deleted_at` is set, record stays in DB
- Client receives deleted records via `includeDeleted=true`
- Needed for sync between devices

## What to store in the idempotency cache?

Store the **entire response** (JSON body):

```javascript
// On success
await cache.set(`idempotency:${key}`, result, 86400);

// On retry
const cached = await cache.get(`idempotency:${key}`);
if (cached) return res.json(cached);
```

For DELETE you can store `{ deleted: true }` or just the fact the operation succeeded.

## How to pass authorization?

The document does not dictate auth. Use your standard API approach:

```http
Authorization: Bearer <token>
```

The client library forwards the header value via callback:
```dart
RestTransport(
  // Returns the full Authorization header value
  token: () async => 'Bearer ${await getToken()}',
)
```

## What is “client-side merge”?

When the server returns `409 Conflict`, the client:

1. Receives `current` (the latest server state)
2. Compares it with local changes
3. Merges data according to configured strategy
4. Repeats the request with `X-Force-Update: true`

Merge strategies are configured in the client library (`serverWins`, `clientWins`, `lastWriteWins`, `custom`).

## Who generates `id`?

**The client generates UUID** before sending. This allows:
- Working offline
- Creating records without a round-trip to the server

The server generates `id` only if the client did not provide one (rare case for POST).

---

## Additional materials

E2E tests in [`packages/offline_first_sync_drift_rest/test/e2e`](../packages/offline_first_sync_drift_rest/test/e2e) show a reference server implementation.
